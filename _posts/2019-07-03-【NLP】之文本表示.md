---
layout: post
title:  "NLP之文本表示"
date:   2019-07-03 15:14:54
categories: 人工智能
tags: AI C#
mathjax: true
---

# 引言

我们在做模型训练的时候，不是直接把文本或者词语传给计算机让其进行计算，而是需要将单词、句子、文本转换成向量或者矩阵进行计算，而如何将文本转换成向量就是本文需要介绍的内容。

介绍内容之前，大家需要先熟悉一些概念。

1. 词库：训练数据中出现的所有单词，可以使用jieba分词统计出来。
2. 混淆矩阵：混淆矩阵是数据科学、数据分析和机器学习中总结分类模型预测结果的情形分析表，以矩阵形式将数据集中的记录按照真实的类别与分类模型作出的分类判断两个标准进行汇总。

# 单词的表示-one-hot

出现为1，不出现为0

每个单词是一个词库数量维度的向量，但是其中只有一个1，其他都是0。

比如：

词典：【我们，又，去，爬山，今天，你们，昨天，跑步】

”我们“对应的向量是：[1, 0, 0, 0,  0, 0, 0, 0]

**缺点**

1. 是浪费空间
2. 无法将单词与单词之间的关系表达出来

比如：按照one-hot表示方式，船和舟是没有关系的。

# 句子的表示-boolean

向量为词库的大小，每个句子对应词库中单词出现与否的情况，出现为1，不出现为0，比如下面的例子：

词典：【我们，又，去，爬山，今天，你们，昨天，跑步】

【“我们”出现了为1，“又“没出现为0，”去“出现了为1，”爬山“出现类为1，”今天“出现了为1，”你们“没出现为0，”昨天“没出现为0，”跑步“出现了为1】

例子：我们今天去爬山，明天去跑步  （1，0，1，1，1，0，0，1）

# 句子的表示-count

向量为词库的大小，每个句子对应词库中单词出现的次数，比如下面的例子：

词典：【我们，又，去，爬山，今天，你们，昨天，跑步】

【“我们”出现的次数1，“又“出现的次数0，”去“出现的次数1，”爬山“出现的次数1，”今天“出现的次数1，”你们“出现的次数0，”昨天“出现的次数0，”跑步“出现的次数0】

计算每个词出现的次数

例子：我们今天去爬山，明天去跑步 （2，0，2，1，1，0，0，1）

# 句子的表示-TF-IDF

tfidf的思想是一个单词在其所在文本中出现的次数越多，在其他文本中出现的次数越少，那么这个单词就能很好的表征单词所在的文本。


```math
TF-IDF = TF * IDF
```


    TF = term frequency 词频
    
    IDF = inverse document frequency 逆向文件频率，表示单词的重要性 


```math
IDF = log(\frac{N}{N(w)})
```

其中：

    N: 文档总数
    
    N(w): 词语w出现在多少个文档中， 出现的次数越多，越不重要

TF-IDF = 词频 * 重要性 

例子：计算三个句子的TF-IDF向量表示：

比如第一个句子的“今天”：TF = 1(句子中“今天”出现的次数)

IDF = log(N/N(w)) 

N 文档总数为 3；N(w) 文档中“今天”出现的次数为2（第一句出现一次，第二句出现一次）。

所以IDF = log(3/2)。其他的同样的计算原理。

![](https://note.youdao.com/yws/public/resource/0c17fbfe0a4f66f6991d8cabaf52d7ab/xmlnote/4814114B36764E4CBC41BC130FE9B47B/26765)

## TF-IDF 的不足

TF-IDF 算法是创建在这样一个假设之上的：对区别文档最有意义的词语应该是那些在文档中出现频率高，而在整个文档集合的其他文档中出现频率少的词语，所以如果特征空间坐标系取tf词频作为测度，就可以体现同类文本的特点。

但是在本质上idf是一种试图抑制噪声的加权，并且单纯地认为文本频率小的单词就越重要，文本频率大的单词就越无用，显然这并不是完全正确的。idf的简单结构并不能有效地反映单词的重要程度和特征词的分布情况，使其无法很好地完成对权值调整的功能，所以**tf-idf法的精度并不是很高**。

**补充概念：**

混淆矩阵：类似于计算准确率和召回率的矩阵。

![](https://note.youdao.com/yws/public/resource/0c17fbfe0a4f66f6991d8cabaf52d7ab/xmlnote/A105B3ACF5AB44A590217BE6C5DBEB85/26904)

    True positive: 正例并且预测也是正例
    False positive： 负例但是预测是正例
    False negative：正例但是预测是负例
    True negative：负例并且预测是负例
    
用检索举例子
    
**准确率 precision**: 检索出来的结果中正确的结果占返回结果总数（返回的结果有的是正例，有的是反例）的比例。

**召回率 recall**: 检索出来的结果正确的结果占所有正例（包括返回回来的正例和没有返回来的正例）的比例

```math
precision = True-positive / (True-positive + False-positive)

recall = True-positive / (True-positive + False-negative)
```


参考：https://www.greedyai.com/

吴恩达-《机器学习》：https://www.coursera.org/learn/machine-learning/lecture/CuONQ/trading-off-precision-and-recall