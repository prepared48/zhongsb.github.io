---
layout: post
title:  "JAVA面试题之一—如何实现锁？如何实现分布式锁？"
date:   2020-07-22 08:14:54
categories: 面试
tags: 大数据 JAVA 分布式
mathjax: true
---

* content
{:toc}

锁的几种实现方式，以及分布式锁的实现。




为什么需要分布式锁？

答：悲观锁、乐观锁、可重入锁、共享锁和独占锁等内容，它们都属于单机锁也就是程序级别的锁，如果在分布式环境下使用就会出现锁不生效的问题，因此我们需要使用分布式锁来解决这个问题。

分布式锁是控制分布式系统之间同步访问共享资源的一种方式。是为了解决分布式系统中，不同的系统或是同一个系统的不同主机共享同一个资源的问题，它通常会采用互斥来保证程序的一致性，这就是分布式锁的用途以及执行原理。

分布式锁的常见实现方式有四种：

- 基于 MySQL 的悲观锁来实现分布式锁，这种方式使用的最少，因为这种实现方式的性能不好，且容易造成死锁；
- 基于 Memcached 实现分布式锁，可使用 add 方法来实现，如果添加成功了则表示分布式锁创建成功；
- 基于 Redis 实现分布式锁，这也是本课时要介绍的重点，可以使用 setnx 方法来实现；
- 基于 ZooKeeper 实现分布式锁，利用 ZooKeeper 顺序临时节点来实现。

为什么redis实现分布式锁最普遍？

- 由于 MySQL 的执行效率问题和死锁问题，所以这种实现方式会被我们先排除掉
- 而 Memcached 和 Redis 的实现方式比较类似，但因为 Redis 技术比较普及，所以会优先使用 Redis 来实现分布式锁.
- ZooKeeper 确实可以很好的实现分布式锁。但此技术在中小型公司的普及率不高，尤其是非 Java 技术栈的公司使用的较少，如果只是为了实现分布式锁而重新搭建一套 ZooKeeper 集群，显然实现成本和维护成本太高.

所以综合以上因素，我们本文会采用 Redis 来实现分布式锁。

## 单机锁

程序中使用的锁叫单机锁，我们日常中所说的“锁”都泛指单机锁，其分类有很多，大体可分为以下几类：

- **悲观锁**，是数据对外界的修改采取保守策略，它认为线程很容易把数据修改掉，因此在整个数据被修改的过程中都会采取锁定状态，直到一个线程使用完，其他线程才可以继续使用，典型应用是 **synchronized**；
- **乐观锁**，和悲观锁的概念恰好相反，乐观锁认为一般情况下数据在修改时不会出现冲突，所以在数据访问之前不会加锁，只是在数据提交更改时，才会对数据进行检测，典型应用是 **ReadWriteLock** 读写锁；
- **可重入锁**，也叫递归锁，指的是同一个线程在外面的函数获取了锁之后，那么内层的函数也可以继续获得此锁，在 Java 语言中 **ReentrantLock** 和 **synchronized** 都是可重入锁；
- **独占锁和共享锁**，只能被单线程持有的锁叫做独占锁，可以被多线程持有的锁叫共享锁，独占锁指的是在任何时候最多只能有一个线程持有该锁，比如 **ReentrantLock** 就是独占锁；而 **ReadWriteLock** 读写锁允许同一时间内有多个线程进行读操作，它就属于共享锁。

## redis 实现分布式锁

### 版本1

    127.0.0.1:6379> setnx lock true
    (integer) 1 #创建锁成功
    #逻辑业务处理...
    127.0.0.1:6379> del lock
    (integer) 1 #
    
问题：没有设置超时时间，如果出现问题，没有释放锁，其他线程需要一直等待该锁被释放。

### 版本2 设置超时时间

    127.0.0.1:6379> setnx lock true
    (integer) 1 #创建锁成功
    127.0.0.1:6379> expire lock 30 #设置锁的(过期)超时时间为 30s
    (integer) 1 
    #逻辑业务处理...
    127.0.0.1:6379> del lock
    (integer) 1 #释放锁

问题：不是原子性操作。如果多个线程同时操作的时候，可能会导致设置超时时间没有执行，没有解决版本1的问题。

### 版本3 redis 2.6.12 版本之后

    127.0.0.1:6379> set lock true ex 30 nx
    OK #创建锁成功

一条命令完成创建锁和过期时间。

问题：如果时间设置过短，任务没有执行完就释放，可能需要重新获取锁，然后又没执行完就被释放。

### 版本4 

在使用 set 命令创建锁时，给 value 值设置一个归属标识。例如，在 value 中插入一个 UUID，每次在删除之前先要判断 UUID 是不是属于当前的线程，如果属于再删除，这样就避免了锁被误删的问题。

借助 lua 脚本，保证操作的原子性。

    /**
     * 释放分布式锁
     * @param jedis Redis客户端
     * @param lockKey 锁的 key
     * @param flagId 锁归属标识
     * @return 是否释放成功
     */
    public static boolean unLock(Jedis jedis, String lockKey, String flagId) {
        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(flagId));
        if ("1L".equals(result)) { // 判断执行结果
            return true;
        }
        return false;
    }

